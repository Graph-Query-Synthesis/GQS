package org.example.gqs;

import com.beust.jcommander.Parameter;
import com.beust.jcommander.Parameters;

import org.example.gqs.Randomly.StringGenerationStrategy;

import java.util.Objects;

@Parameters(separators = "=", commandDescription = "Options applicable to all DBMS")
public class MainOptions {
    public static String mode = "";
    @Parameter(names = "--max-clause-size")
    public static long maxClauseSize = 6 ;

    @Parameter(names = "--designateport")
    public static long debug = -1 ;

    @Parameter(names = "--exp")
    public static String exp = "";
    public static final boolean needReset = true;
    public static final long NO_SET_PORT = -1;


    public static long sidePort = -1;
    
    public static long skipMatch = -1;
    public static long mutationCnt = 1;
    @Parameter(names = {
            "--num-threads" }, description = "How many threads should run concurrently to test separate databases")
    private long nrConcurrentThreads = 1;
    public static long realRandomSeed = -1;
    public static final long timeout = 240;
    @Parameter(names = {"--help", "-h"}, description = "Lists all supported options and commands", help = true)
    private boolean help;

    public static long withClauseSize = 5;
    public static boolean useEmbeddedNeo4j = false;

    public static String startCommandFalkorDB = "";
    public static String deleteCommandFalkorDB = "";
    public static String stopCommandFalkorDB = "";
    public static String deleteFileFalkorDB = "";

    public static String deleteFileKuzuDB = "";


    public static String startCommand;
    public static String deleteCommand;
    public static String stopCommand;
    public static String deleteFile;


    @Parameter(names = {"--num-tries"}, description = "Specifies after how many found errors to stop testing")
    private long totalNumberTries = 100;


    @Parameter(names = {
            "--num-statement-kind-retries"}, description = "Specifies the number of times a specific statement kind (e.g., INSERT) should be retried when the DBMS indicates that it failed")
    private long nrStatementRetryCount = 1000;

    @Parameter(names = "--log-each-select", description = "Logs every statement issued", arity = 1)
    private boolean logEachSelect = true;

    @Parameter(names = "--log-execution-time", description = "Logs the execution time of each statement (requires --log-each-select to be enabled)", arity = 1)
    private boolean logExecutionTime = false;


    @Parameter(names = "--print-progress-information", description = "Whether to print progress information such as the number of databases generated or queries issued", arity = 1)
    private boolean printProgressInformation = true;

    @Parameter(names = "--print-progress-summary", description = "Whether to print an execution summary when exiting SQLancer", arity = 1)
    private boolean printProgressSummary;
    @Parameter(names = {
            "--random-seed"}, description = "A seed value != -1 that can be set to make the query and database generation deterministic")
    public long randomSeed = -1;
    @Parameter(names = "--timeout-seconds", description = "The timeout in seconds")
    private long timeoutSeconds = -1;

    @Parameter(names = "--max-generated-databases", description = "The maximum number of databases that are generated by each thread")
    private long maxGeneratedDatabases = -1;

    @Parameter(names = "--exit-code-error", description = "The exit code that should be returned when an error is encountered (or a bug is found)")
    private long errorExitCode = -1;

    @Parameter(names = "--print-statements", description = "print all statements to stdout, before they are sent to the DBMS (not yet implemented for all oracles)", arity = 1)
    private boolean printStatements;

    @Parameter(names = "--print-succeeding-statements", description = "print statements that are successfully processed by the DBMS to stdout (not yet implemented for all oracles)", arity = 1)
    private boolean printSucceedingStatements;

    @Parameter(names = "--test-only-nonempty-tables", description = "Test only databases each of whose tables contain at least a single row", arity = 1)
    private boolean testOnlyWithMoreThanZeroRows;

    @Parameter(names = "--pqs-test-aggregates", description = "Partially test aggregate functions when all tables contain only a single row.", arity = 1)
    private boolean testAggregateFunctions;

    @Parameter(names = "--random-string-generation", description = "Select the -string eneration approach")
    private StringGenerationStrategy randomStringGenerationStrategy = StringGenerationStrategy.ALPHANUMERIC;

    @Parameter(names = "--string-constant-max-length", description = "Specify the maximum-length of generated string constants")
    private long maxStringConstantLength = 10;

    @Parameter(names = "--use-constant-caching", description = "Specifies whether constants should be cached and re-used with a certain probability", arity = 1)
    private boolean useConstantCaching = true;

    @Parameter(names = "--use-connection-test", description = "Test whether the DBMS is accessible before trying to connect using multiple threads", arity = 1)
    private boolean useConnectionTest = false;

    @Parameter(names = "--constant-cache-size", description = "Specifies the size of the constant cache. This option only takes effect when constant caching is enabled")
    private long constantCacheSize = 100;

    @Parameter(names = "--database-prefix", description = "The prefix used for each database created")
    private String databasePrefix = "database";

    @Parameter(names = "--tcp-guidance")
    private boolean tcpGuidance = false;

    @Parameter(names = "--algorithm")
    private Algorithms algorithm = Algorithms.COMPARED3;

    @Parameter(names = "--coverage-port")
    private int coverage_port = 0;

    @Parameter(names = "--label-num")


    public static long labelNum = 10;

    @Parameter(names = "--avoid-limitations")
    private boolean avoidLimitations = false;



    @Parameter(names = "--max-node-num")

    private long maxNodeNum = 20;
    public static long maxRelationNumber = 50;

    @Parameter(names = "--force-compare" )
    private boolean forceCompareAndIgnoreException = false;

    @Parameter(names = "--manual-starting")
    private long manualStarting = 0;

    public long getManualStarting() {
        return manualStarting;
    }

    public boolean forceCompareAndIgnoreException() {
        return forceCompareAndIgnoreException;
    }

    public long getMaxClauseSize() {
        return maxClauseSize;
    }

    public long getMaxNodeNum() {
        return maxNodeNum;
    }

    public boolean isAvoidLimitations(){
        return avoidLimitations;
    }

    public long getLabelNum() {
        return labelNum;
    }

    public long getTotalNumberTries() {
        return totalNumberTries;
    }

    public int getNumberConcurrentThreads() {
        return (int) nrConcurrentThreads;
    }

    public boolean logEachSelect() {
        return logEachSelect;
    }

    public boolean printAllStatements() {
        if (printSucceedingStatements && printStatements) {
            throw new AssertionError();
        }
        return printStatements;
    }

    public boolean printSucceedingStatements() {
        if (printStatements && printSucceedingStatements) {
            throw new AssertionError();
        }
        return printSucceedingStatements;
    }

    public boolean logExecutionTime() {
        if (!logEachSelect) {
            throw new AssertionError();
        }
        return logExecutionTime;
    }

    public long getNrQueries() {
        if(Objects.equals(MainOptions.mode, "memgraph") || Objects.equals(MainOptions.mode, "thinker"))
            return 100;
        else
            return 300;
    }

    public long getNrStatementRetryCount() {
        return nrStatementRetryCount;
    }

    public boolean printProgressInformation() {
        return printProgressInformation;
    }

    public boolean printProgressSummary() {
        return printProgressSummary;
    }

    public long getTimeoutSeconds() {
        return timeoutSeconds;
    }

    public long getMaxGeneratedDatabases() {
        return maxGeneratedDatabases;
    }

    public long getErrorExitCode() {
        return errorExitCode;
    }

    public long getRandomSeed() {
        return randomSeed;
    }

    public boolean testOnlyWithMoreThanZeroRows() {
        return testOnlyWithMoreThanZeroRows;
    }

    public StringGenerationStrategy getRandomStringGenerationStrategy() {
        return randomStringGenerationStrategy;
    }

    public long getMaxStringConstantLength() {
        return maxStringConstantLength;
    }

    public boolean useConstantCaching() {
        return useConstantCaching;
    }

    public long getConstantCacheSize() {
        return constantCacheSize;
    }

    public boolean isHelp() {
        return help;
    }

    public String getDatabasePrefix() {
        return mode + databasePrefix;
    }

    public boolean performConnectionTest() {
        return useConnectionTest;
    }

    public boolean isTcpGuidance() {
        return tcpGuidance;
    }

    public Algorithms getAlgorithm(){
        return algorithm;
    }

    public int getCoverage_port() {
        return coverage_port;
    }
    public static boolean assistSkipMatch = false;

    public enum Algorithms{
        SIMPLE, PATTERN_GUIDED, MANUAL, NON_EMPTY, COMPARED1, COMPARED2, COMPARED3, COMPARED4, COMPARED5,
        MANUAL_PERF, ENUM
    }
    public static String standard = "";
    public static String[] aggregationFunction = {"count", "sum", "avg", "min", "max", "collect", "stdev", "stdevp"};
    public static String[] floatFunction = {"avg", "acos", "asin", "atan", "atan2", "ceil", "cos", "e", "exp", "floor", "log", "log10", "pi", "round", "sin", "sqrt", "tan", "stdev", "stdevp"};
    public static String[] nonScalarFunction = {"startNode", "endNode", "collect", "split", "tail", "head", "last", "labels", "range"};

    public static boolean isAggregateFunction(String s){
        for(String str : aggregationFunction){
            if(str.equals(s))
                return true;
        }
        return false;
    }

    public static boolean isFloatFunction(String s){
        for(String str : floatFunction){
            if(str.equals(s))
                return true;
        }
        return false;
    }

    public static boolean isScalarFunction(String s){
        for(String str : nonScalarFunction){
            if(str.equals(s))
                return false;
        }
        return true;
    }

    public static String getLogPath()
    {
        if(debug == -1)
            return "logs/"+MainOptions.maxClauseSize + "/";
        else
            return "logs/"+MainOptions.maxClauseSize+"/";
    }
}
